use blf::{read_blf_from_file, LogObject, StreamingBlfReader};
use gpui::{prelude::*, *};
use parser::dbc::{DbcDatabase, DbcParser};
use parser::ldf::{LdfDatabase, LdfParser};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::path::PathBuf;

// Á™óÂè£ÈÖçÁΩÆÈÄâÈ°π
fn get_window_options() -> WindowOptions {
    WindowOptions {
        window_bounds: Some(WindowBounds::Windowed(Bounds {
            origin: Point::new(px(200.0), px(150.0)),
            size: gpui::Size {
                width: px(1600.0),
                height: px(1000.0),
            },
        })),
        titlebar: Some(TitlebarOptions {
            title: None,
            appears_transparent: true,
            traffic_light_position: Some(Point::new(px(12.0), px(12.0))),
        }),
        ..Default::default()
    }
}

// ÂõûÊîæÊéßÂà∂Âô®
#[derive(Debug, Clone)]
pub struct PlaybackController {
    pub is_playing: bool,
    pub current_time: f64,
    pub start_time: f64,
    pub end_time: f64,
    pub playback_speed: f32,
    pub messages: Vec<LogObject>,
    pub filtered_messages: Vec<(usize, f64)>, // (message_index, relative_time)
}

impl PlaybackController {
    pub fn new() -> Self {
        Self {
            is_playing: false,
            current_time: 0.0,
            start_time: 0.0,
            end_time: 0.0,
            playback_speed: 1.0,
            messages: Vec::new(),
            filtered_messages: Vec::new(),
        }
    }

    pub fn load_messages(&mut self, messages: Vec<LogObject>, start_timestamp: u64) {
        self.messages = messages;
        if !self.messages.is_empty() {
            self.start_time = 0.0;
            self.current_time = 0.0;

            // Calculate relative timestamps and find end time
            self.filtered_messages = self
                .messages
                .iter()
                .enumerate()
                .map(|(i, msg)| {
                    let relative_time = (msg.timestamp() - start_timestamp) as f64 / 1_000_000.0; // Convert to seconds
                    (i, relative_time)
                })
                .collect();

            if let Some((_, last_time)) = self.filtered_messages.last() {
                self.end_time = *last_time;
            }
        }
    }

    pub fn play(&mut self) {
        self.is_playing = true;
    }

    pub fn pause(&mut self) {
        self.is_playing = false;
    }

    pub fn stop(&mut self) {
        self.is_playing = false;
        self.current_time = 0.0;
    }

    pub fn set_time(&mut self, time: f64) {
        self.current_time = time.max(0.0).min(self.end_time);
    }

    pub fn set_speed(&mut self, speed: f32) {
        self.playback_speed = speed.max(0.1).min(10.0);
    }

    pub fn update(&mut self, delta_time: f64) {
        if self.is_playing {
            self.current_time += delta_time * self.playback_speed as f64;
            if self.current_time >= self.end_time {
                self.current_time = self.end_time;
                self.is_playing = false;
            }
        }
    }

    pub fn get_visible_messages(&self, window_size: usize) -> Vec<&LogObject> {
        // Get messages up to current time
        let current_messages: Vec<_> = self
            .filtered_messages
            .iter()
            .filter(|(_, time)| *time <= self.current_time)
            .map(|(index, _)| &self.messages[*index])
            .collect();

        // Return the last `window_size` messages
        let start_idx = current_messages.len().saturating_sub(window_size);
        current_messages[start_idx..].to_vec()
    }

    pub fn format_time(seconds: f64) -> String {
        let total_seconds = seconds as u64;
        let hours = total_seconds / 3600;
        let minutes = (total_seconds % 3600) / 60;
        let secs = total_seconds % 60;
        let millis = ((seconds - total_seconds as f64) * 1000.0) as u32;

        if hours > 0 {
            format!("{:02}:{:02}:{:02}.{:03}", hours, minutes, secs, millis)
        } else {
            format!("{:02}:{:02}.{:03}", minutes, secs, millis)
        }
    }
}

// ÂÆö‰πâÊûö‰∏æÂíåÁªìÊûÑ‰Ωì
#[derive(Debug, Serialize, Deserialize, Clone, PartialEq, Copy)]
enum ChannelType {
    CAN,
    LIN,
}

#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)]
struct LibraryVersion {
    name: String,
    path: String,
    date: String,
}

#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)]
struct SignalLibrary {
    id: String,
    name: String,
    versions: Vec<LibraryVersion>,
}

#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)]
struct ChannelMapping {
    #[serde(default = "default_channel_type")]
    channel_type: ChannelType,
    #[serde(alias = "channel")]
    channel_id: u16,
    #[serde(default)]
    path: String,
    #[serde(default)]
    description: String,
    library_id: Option<String>,
    version_name: Option<String>,
}

fn default_channel_type() -> ChannelType {
    ChannelType::CAN
}

#[derive(Debug, Serialize, Deserialize, Clone, Default)]
struct AppConfig {
    libraries: Vec<SignalLibrary>,
    mappings: Vec<ChannelMapping>,
    active_library_id: Option<String>,
    active_version_name: Option<String>,
}

#[derive(Debug, Clone, PartialEq)]
enum AppView {
    LogView,
    ConfigView,
    ChartView,
}

// ÂÆö‰πâÊàë‰ª¨ÁöÑÊ†πËßÜÂõæÁªìÊûÑ
struct CanViewApp {
    current_view: AppView,
    messages: Vec<LogObject>,
    status_msg: SharedString,
    dbc_channels: HashMap<u16, DbcDatabase>,
    ldf_channels: HashMap<u16, LdfDatabase>,
    app_config: AppConfig,
    selected_signals: Vec<String>,
    start_time: Option<chrono::NaiveDateTime>,
    config_dir: PathBuf,
    config_file_path: PathBuf,
    playback_controller: PlaybackController,
    last_update_time: std::time::Instant,
    streaming_reader: Option<StreamingBlfReader>,
    is_streaming_mode: bool,
}

impl CanViewApp {
    fn new() -> Self {
        let mut app = Self {
            current_view: AppView::LogView,
            messages: Vec::new(),
            status_msg: "Ready".into(),
            dbc_channels: HashMap::new(),
            ldf_channels: HashMap::new(),
            app_config: AppConfig::default(),
            selected_signals: Vec::new(),
            start_time: None,
            config_dir: PathBuf::from("."),
            config_file_path: PathBuf::from("multi_channel_config.json"),
            playback_controller: PlaybackController::new(),
            last_update_time: std::time::Instant::now(),
            streaming_reader: None,
            is_streaming_mode: false,
        };

        // ÂêØÂä®Êó∂Âä†ËΩΩÈÖçÁΩÆ
        app.load_startup_config();
        app
    }

    fn load_startup_config(&mut self) {
        let path = PathBuf::from("multi_channel_config.json");
        if path.exists() {
            self.status_msg = "Found saved config, loading...".into();
            if let Ok(content) = std::fs::read_to_string(&path) {
                match serde_json::from_str::<AppConfig>(&content) {
                    Ok(mut config) => {
                        // Fill in missing paths from library versions for legacy configs
                        for mapping in &mut config.mappings {
                            if mapping.path.is_empty() {
                                if let Some(lib_id) = &mapping.library_id {
                                    if let Some(version_name) = &mapping.version_name {
                                        if let Some(library) =
                                            config.libraries.iter().find(|l| l.id == *lib_id)
                                        {
                                            if let Some(version) = library
                                                .versions
                                                .iter()
                                                .find(|v| v.name == *version_name)
                                            {
                                                mapping.path = version.path.clone();
                                            }
                                        }
                                    }
                                }
                            }
                        }

                        self.app_config = config.clone();
                        self.config_dir = path
                            .parent()
                            .unwrap_or(std::path::Path::new("."))
                            .to_path_buf();
                        self.config_file_path = path.clone();
                        self.status_msg = "Configuration loaded.".into();

                        // Auto-Apply if Active Version Exists
                        if let (Some(l_id), Some(v_name)) =
                            (&config.active_library_id, &config.active_version_name)
                        {
                            self.apply_active_version(l_id, v_name);
                        }
                    }
                    Err(e) => {
                        self.status_msg =
                            format!("Config load error: {}. Using default config.", e).into();
                        // Initialize with empty config instead of failing
                        self.app_config = AppConfig::default();
                    }
                }
            }
        } else {
            self.status_msg = "Ready - GPUI version initialized".into();
        }
    }

    fn apply_active_version(&mut self, library_id: &str, version_name: &str) {
        let parent = &self.config_dir;
        self.status_msg = format!("Applying active version: {}...", version_name).into();

        self.dbc_channels.clear();
        self.ldf_channels.clear();

        for mapping in &self.app_config.mappings {
            if mapping.library_id.as_ref() == Some(&library_id.to_string())
                && mapping.version_name.as_ref() == Some(&version_name.to_string())
            {
                // Try to find the actual file path from library versions
                let file_path = if !mapping.path.is_empty() {
                    mapping.path.clone()
                } else if let Some(library) = self
                    .app_config
                    .libraries
                    .iter()
                    .find(|l| l.id == library_id)
                {
                    if let Some(version) =
                        library.versions.iter().find(|v| v.name == version_name)
                    {
                        version.path.clone()
                    } else {
                        continue;
                    }
                } else {
                    continue;
                };

                let full_path = parent.join(&file_path);
                if let Ok(content) = std::fs::read_to_string(&full_path) {
                    match mapping.channel_type {
                        ChannelType::CAN => {
                            let parser = DbcParser::new();
                            if let Ok(db) = parser.parse(&content) {
                                self.dbc_channels.insert(mapping.channel_id, db);
                            }
                        }
                        ChannelType::LIN => {
                            let parser = LdfParser::new();
                            if let Ok(db) = parser.parse(&content) {
                                self.ldf_channels.insert(mapping.channel_id, db);
                            }
                        }
                }
            }
        }
        self.status_msg = format!(
            "Loaded {} DBC and {} LIN channels",
            self.dbc_channels.len(),
            self.ldf_channels.len()
        )
        .into();
    }

    fn open_blf_file(&mut self, _cx: &mut Context<Self>) {
        if let Some(path) = rfd::FileDialog::new()
            .add_filter("BLF Files", &["blf", "bin"])
            .pick_file()
        {
            self.open_blf_file_with_path(path);
        }
    }

    fn open_blf_file_with_path(&mut self, path: std::path::PathBuf) {
        // Check file size to determine if we should use streaming mode
        let file_size = std::fs::metadata(&path).map(|meta| meta.len()).unwrap_or(0);

        // Use streaming mode for files larger than 50MB
        if file_size > 50 * 1024 * 1024 {
            self.open_blf_file_streaming(path);
        } else {
            self.open_blf_file_normal(path);
        }
    }

    fn open_blf_file_normal(&mut self, path: std::path::PathBuf) {
        self.status_msg = "Loading BLF...".into();
        self.is_streaming_mode = false;

        match read_blf_from_file(&path) {
            Ok(result) => {
                self.status_msg = format!("Loaded BLF: {} objects", result.objects.len()).into();

                // Parse start time
                let st = result.file_stats.measurement_start_time.clone();
                let date_opt =
                    chrono::NaiveDate::from_ymd_opt(st.year as i32, st.month as u32, st.day as u32);
                let time_opt = chrono::NaiveTime::from_hms_milli_opt(
                    st.hour as u32,
                    st.minute as u32,
                    st.second as u32,
                    st.milliseconds as u32,
                );

                if let (Some(date), Some(time)) = (date_opt, time_opt) {
                    self.start_time = Some(chrono::NaiveDateTime::new(date, time));
                } else {
                    self.start_time = None;
                }

                // Load messages into playback controller
                let start_timestamp = if let Some(first_msg) = result.objects.first() {
                    first_msg.timestamp()
                } else {
                    0
                };

                self.playback_controller
                    .load_messages(result.objects.clone(), start_timestamp);
                self.messages = result.objects;
            }
            Err(e) => {
                self.status_msg = format!("Error: {:?}", e).into();
            }
        }
    }

    fn open_blf_file_streaming(&mut self, path: std::path::PathBuf) {
        self.status_msg = "Loading large BLF file (streaming mode)...".into();
        self.is_streaming_mode = true;

        match StreamingBlfReader::new(&path) {
            Ok(mut reader) => {
                let file_stats = reader.file_stats().clone();

                // Parse start time
                let st = file_stats.measurement_start_time.clone();
                let date_opt =
                    chrono::NaiveDate::from_ymd_opt(st.year as i32, st.month as u32, st.day as u32);
                let time_opt = chrono::NaiveTime::from_hms_milli_opt(
                    st.hour as u32,
                    st.minute as u32,
                    st.second as u32,
                    st.milliseconds as u32,
                );

                if let (Some(date), Some(time)) = (date_opt, time_opt) {
                    self.start_time = Some(chrono::NaiveDateTime::new(date, time));
                } else {
                    self.start_time = None;
                }

                // Load initial batch of messages
                match reader.read_next_batch(1000) {
                    Ok(initial_messages) => {
                        self.status_msg = format!(
                            "Loaded BLF (streaming): {} initial objects, {} total estimated",
                            initial_messages.len(),
                            file_stats.object_count
                        )
                        .into();

                        // Load messages into playback controller
                        let start_timestamp = if let Some(first_msg) = initial_messages.first() {
                            first_msg.timestamp()
                        } else {
                            0
                        };

                        self.playback_controller
                            .load_messages(initial_messages.clone(), start_timestamp);
                        self.messages = initial_messages;
                        self.streaming_reader = Some(reader);
                    }
                    Err(e) => {
                        self.status_msg = format!("Error reading initial batch: {:?}", e).into();
                    }
                }
            }
            Err(e) => {
                self.status_msg = format!("Error opening streaming reader: {:?}", e).into();
            }
        }
    }

    fn load_more_messages(&mut self) {
        if let Some(reader) = &mut self.streaming_reader {
            if !reader.is_eof() {
                match reader.read_next_batch(500) {
                    Ok(new_messages) => {
                        if !new_messages.is_empty() {
                            let start_timestamp = if let Some(first_msg) = self.messages.first() {
                                first_msg.timestamp()
                            } else if let Some(first_msg) = new_messages.first() {
                                first_msg.timestamp()
                            } else {
                                0
                            };

                            self.messages.extend(new_messages.clone());
                            self.playback_controller
                                .load_messages(self.messages.clone(), start_timestamp);

                            self.status_msg = format!(
                                "Loaded {} total objects (streaming: {:.1}%)",
                                self.messages.len(),
                                reader.progress() * 100.0
                            )
                            .into();
                        }
                    }
                    Err(e) => {
                        self.status_msg = format!("Error loading more messages: {:?}", e).into();
                    }
                }
            }
        }
    }

    fn load_config(&mut self, _cx: &mut Context<Self>) {
        if let Some(path) = rfd::FileDialog::new()
            .add_filter("Config Files", &["json"])
            .pick_file()
        {
            self.status_msg = "Loading config...".into();
            if let Ok(content) = std::fs::read_to_string(&path) {
                match serde_json::from_str::<AppConfig>(&content) {
                    Ok(config) => {
                        self.app_config = config;
                        self.config_dir = path.parent()
                            .unwrap_or(std::path::Path::new("."))
                            .to_path_buf();
                        self.config_file_path = path;
                        self.status_msg = "Configuration loaded successfully".into();
                    }
                    Err(e) => {
                        self.status_msg = format!("Config Error: {}", e).into();
                    }
                }
            }
        }
    }

    fn get_timestamp_string(&self, timestamp: u64) -> String {
        if let Some(start) = &self.start_time {
            let msg_time = *start + chrono::Duration::nanoseconds(timestamp as i64);
            msg_time.format("%H:%M:%S%.3f").to_string()
        } else {
            format!("{:.3}", timestamp as f64 / 1000000.0)
        }
    }

    fn render_message_row(&self, msg: &LogObject, index: usize) -> impl IntoElement {
        let (time_str, channel_id, msg_type, id_str, dlc_str, data_str, signals_str) = match msg {
            LogObject::CanMessage(can_msg) => {
                let timestamp = can_msg.header.object_time_stamp;
                let time_str = self.get_timestamp_string(timestamp);
                let data_hex = can_msg
                    .data
                    .iter()
                    .take(can_msg.dlc as usize)
                    .map(|b| format!("{:02X}", b))
                    .collect::<Vec<_>>()
                    .join(" ");
                let signals = if let Some(db) = self.dbc_channels.get(&can_msg.channel) {
                    if let Some(message) = db.messages.get(&can_msg.id) {
                        message
                            .signals
                            .iter()
                            .map(|(name, _signal)| {
                                // Simplified signal extraction for now
                                format!("{}=?", name)
                            })
                            .collect::<Vec<_>>()
                            .join(", ")
                    } else {
                        String::new()
                    }
                } else {
                    String::new()
                };

                (
                    time_str,
                    can_msg.channel,
                    "CAN".to_string(),
                    format!("0x{:03X}", can_msg.id),
                    can_msg.dlc.to_string(),
                    data_hex,
                    signals,
                )
            }
            LogObject::LinMessage(lin_msg) => {
                let timestamp = lin_msg.header.object_time_stamp;
                let time_str = self.get_timestamp_string(timestamp);
                let data_hex = lin_msg
                    .data
                    .iter()
                    .take(lin_msg.dlc as usize)
                    .map(|b| format!("{:02X}", b))
                    .collect::<Vec<_>>()
                    .join(" ");

                (
                    time_str,
                    lin_msg.channel,
                    "LIN".to_string(),
                    format!("0x{:02X}", lin_msg.id),
                    lin_msg.dlc.to_string(),
                    data_hex,
                    String::new(), // LIN signals parsing not implemented yet
                )
            }
            _ => (
                "Unknown".to_string(),
                0,
                "Other".to_string(),
                "-".to_string(),
                "-".to_string(),
                "-".to_string(),
                String::new(),
            ),
        };

        let bg_color = if index % 2 == 0 {
            rgb(0x181818)
        } else {
            rgb(0x1a1a1a)
        };

        div()
            .flex()
            .w_full()
            .min_h(px(22.))
            .bg(bg_color)
            .border_b_1()
            .border_color(rgb(0x2a2a2a))
            .items_center()
            .text_xs()
            .text_color(rgb(0xd1d5db))
            .hover(|style| style.bg(rgb(0x1f2937)))
            .cursor_pointer()
            .child(
                div()
                    .w(px(100.))
                    .px_3()
                    .py_1()
                    .text_color(rgb(0x9ca3af))
                    .child(time_str),
            )
            .child(
                div()
                    .w(px(40.))
                    .px_2()
                    .py_1()
                    .text_color(rgb(0x60a5fa))
                    .child(channel_id.to_string()),
            )
            .child(
                div()
                    .w(px(50.))
                    .px_2()
                    .py_1()
                    .text_color(rgb(0x34d399))
                    .child(msg_type),
            )
            .child(
                div()
                    .w(px(70.))
                    .px_2()
                    .py_1()
                    .text_color(rgb(0xfbbf24))
                    .child(id_str),
            )
            .child(div().w(px(40.)).px_2().py_1().child(dlc_str))
            .child(
                div()
                    .w(px(150.))
                    .px_2()
                    .py_1()
                    .text_color(rgb(0xa78bfa))
                    .child(data_str),
            )
            .child(
                div()
                    .flex_1()
                    .px_2()
                    .py_1()
                    .text_color(rgb(0x9ca3af))
                    .child(signals_str),
            )
    }

    fn open_blf_file(&mut self, _cx: &mut Context<Self>) {
        if let Some(path) = rfd::FileDialog::new()
            .add_filter("BLF Files", &["blf", "bin"])
            .pick_file()
        {
            self.open_blf_file_with_path(path);
        }
    }

    fn open_blf_file_with_path(&mut self, path: std::path::PathBuf) {
        // Check file size to determine if we should use streaming mode
        let file_size = std::fs::metadata(&path).map(|meta| meta.len()).unwrap_or(0);

        // Use streaming mode for files larger than 50MB
        if file_size > 50 * 1024 * 1024 {
            self.open_blf_file_streaming(path);
        } else {
            self.open_blf_file_normal(path);
        }
    }

    fn open_blf_file_normal(&mut self, path: std::path::PathBuf) {
        self.status_msg = "Loading BLF...".into();
        self.is_streaming_mode = false;

        match read_blf_from_file(&path) {
            Ok(result) => {
                self.status_msg = format!("Loaded BLF: {} objects", result.objects.len()).into();

                // Parse start time
                let st = result.file_stats.measurement_start_time.clone();
                let date_opt =
                    chrono::NaiveDate::from_ymd_opt(st.year as i32, st.month as u32, st.day as u32);
                let time_opt = chrono::NaiveTime::from_hms_milli_opt(
                    st.hour as u32,
                    st.minute as u32,
                    st.second as u32,
                    st.milliseconds as u32,
                );

                if let (Some(date), Some(time)) = (date_opt, time_opt) {
                    self.start_time = Some(chrono::NaiveDateTime::new(date, time));
                } else {
                    self.start_time = None;
                }

                // Load messages into playback controller
                let start_timestamp = if let Some(first_msg) = result.objects.first() {
                    first_msg.timestamp()
                } else {
                    0
                };

                self.playback_controller
                    .load_messages(result.objects.clone(), start_timestamp);
                self.messages = result.objects;
            }
            Err(e) => {
                self.status_msg = format!("Error: {:?}", e).into();
            }
        }
    }

    fn open_blf_file_streaming(&mut self, path: std::path::PathBuf) {
        self.status_msg = "Loading large BLF file (streaming mode)...".into();
        self.is_streaming_mode = true;

        match StreamingBlfReader::new(&path) {
            Ok(mut reader) => {
                let file_stats = reader.file_stats().clone();

                // Parse start time
                let st = file_stats.measurement_start_time.clone();
                let date_opt =
                    chrono::NaiveDate::from_ymd_opt(st.year as i32, st.month as u32, st.day as u32);
                let time_opt = chrono::NaiveTime::from_hms_milli_opt(
                    st.hour as u32,
                    st.minute as u32,
                    st.second as u32,
                    st.milliseconds as u32,
                );

                if let (Some(date), Some(time)) = (date_opt, time_opt) {
                    self.start_time = Some(chrono::NaiveDateTime::new(date, time));
                } else {
                    self.start_time = None;
                }

                // Load initial batch of messages
                match reader.read_next_batch(1000) {
                    Ok(initial_messages) => {
                        self.status_msg = format!(
                            "Loaded BLF (streaming): {} initial objects, {} total estimated",
                            initial_messages.len(),
                            file_stats.object_count
                        )
                        .into();

                        // Load messages into playback controller
                        let start_timestamp = if let Some(first_msg) = initial_messages.first() {
                            first_msg.timestamp()
                        } else {
                            0
                        };

                        self.playback_controller
                            .load_messages(initial_messages.clone(), start_timestamp);
                        self.messages = initial_messages;
                        self.streaming_reader = Some(reader);
                    }
                    Err(e) => {
                        self.status_msg = format!("Error reading initial batch: {:?}", e).into();
                    }
                }
            }
            Err(e) => {
                self.status_msg = format!("Error opening streaming reader: {:?}", e).into();
            }
        }
    }

    fn load_more_messages(&mut self) {
        if let Some(reader) = &mut self.streaming_reader {
            if !reader.is_eof() {
                match reader.read_next_batch(500) {
                    Ok(new_messages) => {
                        if !new_messages.is_empty() {
                            let start_timestamp = if let Some(first_msg) = self.messages.first() {
                                first_msg.timestamp()
                            } else if let Some(first_msg) = new_messages.first() {
                                first_msg.timestamp()
                            } else {
                                0
                            };

                            self.messages.extend(new_messages.clone());
                            self.playback_controller
                                .load_messages(self.messages.clone(), start_timestamp);

                            self.status_msg = format!(
                                "Loaded {} total objects (streaming: {:.1}%)",
                                self.messages.len(),
                                reader.progress() * 100.0
                            )
                            .into();
                        }
                    }
                    Err(e) => {
                        self.status_msg = format!("Error loading more messages: {:?}", e).into();
                    }
                }
            }
        }
    }

    fn load_config(&mut self, _cx: &mut Context<Self>) {
        if let Some(path) = rfd::FileDialog::new()
            .add_filter("Config Files", &["json"])
            .pick_file()
        {
            self.status_msg = "Loading config...".into();
            if let Ok(content) = std::fs::read_to_string(&path) {
                match serde_json::from_str::<AppConfig>(&content) {
                    Ok(config) => {
                        self.app_config = config;
                        self.config_dir = path.parent()
                            .unwrap_or(std::path::Path::new("."))
                            .to_path_buf();
                        self.config_file_path = path;
                        self.status_msg = "Configuration loaded successfully".into();
                    }
                    Err(e) => {
                        self.status_msg = format!("Config Error: {}", e).into();
                    }
                }
            }
        }
    }

    fn get_timestamp_string(&self, timestamp: u64) -> String {
        if let Some(start_time) = &self.start_time {
            let duration = chrono::Duration::nanoseconds(timestamp as i64);
            let msg_time = *start_time + duration;
            msg_time.format("%H:%M:%S.%3f").to_string()
        } else {
            format!("{:.6}", timestamp as f64 / 1_000_000.0)
        }
    }

    fn render_message_row(&self, msg: &LogObject, index: usize) -> impl IntoElement {
        let bg_color = if index % 2 == 0 {
            rgb(0x1f1f1f)
        } else {
            rgb(0x181818)
        };

        let (msg_type, id_str, dlc_str, data_str, channel_str) = match msg {
            LogObject::CanMessage(can_msg) => (
                "CAN",
                format!("0x{:X}", can_msg.id),
                can_msg.dlc.to_string(),
                format!("{:02X?}", &can_msg.data[..can_msg.dlc.min(8) as usize]),
                can_msg.channel.to_string(),
            ),
            LogObject::CanMessage2(can_msg) => (
                "CAN2",
                format!("0x{:X}", can_msg.id),
                can_msg.dlc.to_string(),
                format!("{:02X?}", &can_msg.data[..can_msg.dlc.min(can_msg.data.len() as u8) as usize]),
                can_msg.channel.to_string(),
            ),
            LogObject::CanFdMessage(can_msg) => (
                "CANFD",
                format!("0x{:X}", can_msg.id),
                can_msg.valid_payload_length.to_string(),
                format!("{:02X?}", &can_msg.data[..can_msg.valid_payload_length.min(64) as usize]),
                can_msg.channel.to_string(),
            ),
            LogObject::CanFdMessage64(can_msg) => (
                "CANFD64",
                format!("0x{:X}", can_msg.id),
                can_msg.valid_payload_length.to_string(),
                format!("{:02X?}", &can_msg.data[..can_msg.valid_payload_length.min(64) as usize]),
                can_msg.channel.to_string(),
            ),
            LogObject::LinMessage(lin_msg) => (
                "LIN",
                format!("0x{:X}", lin_msg.id),
                lin_msg.dlc.to_string(),
                format!("{:02X?}", &lin_msg.data[..lin_msg.dlc.min(8) as usize]),
                lin_msg.channel.to_string(),
            ),
            _ => (
                "OTHER",
                "-".to_string(),
                "-".to_string(),
                "-".to_string(),
                "-".to_string(),
            ),
        };

        let signals_str = match msg {
            LogObject::CanMessage(can_msg) => {
                if let Some(dbc) = self.dbc_channels.get(&can_msg.channel) {
                    if let Some(message) = dbc.messages.get(&can_msg.id) {
                        let mut signals = Vec::new();
                        for signal in &message.signals {
                            if let Ok(value) = signal.extract_value(&can_msg.data) {
                                signals.push(format!("{}={}", signal.name, value));
                            }
                        }
                        signals.join(", ")
                    } else {
                        "No DBC definition".to_string()
                    }
                } else {
                    "No DBC loaded".to_string()
                }
            }
            LogObject::LinMessage(lin_msg) => {
                if let Some(ldf) = self.ldf_channels.get(&lin_msg.channel) {
                    if let Some(frame) = ldf.frames.get(&(lin_msg.id as u8)) {
                        let mut signals = Vec::new();
                        for signal in &frame.signals {
                            signals.push(format!("{}=?", signal.name));
                        }
                        signals.join(", ")
                    } else {
                        "No LDF definition".to_string()
                    }
                } else {
                    "No LDF loaded".to_string()
                }
            }
            _ => "N/A".to_string(),
        };

        let timestamp_str = self.get_timestamp_string(msg.timestamp());

        div()
            .w_full()
            .h(px(24.))
            .bg(bg_color)
            .flex()
            .items_center()
            .text_xs()
            .text_color(rgb(0xd1d5db))
            .hover(|style| style.bg(rgb(0x2a2a2a)))
            .child(
                div()
                    .w(px(100.))
                    .px_3()
                    .py_1()
                    .text_color(rgb(0x9ca3af))
                    .child(timestamp_str),
            )
            .child(
                div()
                    .w(px(40.))
                    .px_2()
                    .py_1()
                    .text_color(rgb(0x9ca3af))
                    .child(channel_str),
            )
            .child(
                div()
                    .w(px(50.))
                    .px_2()
                    .py_1()
                    .text_color(rgb(0x60a5fa))
                    .child(msg_type),
            )
            .child(
                div()
                    .w(px(70.))
                    .px_2()
                    .py_1()
                    .text_color(rgb(0xfbbf24))
                    .child(id_str),
            )
            .child(
                div()
                    .w(px(40.))
                    .px_2()
                    .py_1()
                    .text_color(rgb(0x34d399))
                    .child(dlc_str),
            )
            .child(
                div()
                    .w(px(150.))
                    .px_2()
                    .py_1()
                    .text_color(rgb(0xf472b6))
                    .child(data_str),
            )
            .child(
                div()
                    .flex_1()
                    .px_2()
                    .py_1()
                    .text_color(rgb(0x9ca3af))
                    .child(signals_str),
            )
    }

    fn render_log_view(&self) -> impl IntoElement {
        div()
            .size_full()
            .flex()
            .flex_col()
            .child(
                // Playback controls
                div()
                    .w_full()
                    .h(px(40.))
                    .bg(rgb(0x1a1a1a))
                    .border_b_1()
                    .border_color(rgb(0x2a2a2a))
                    .flex()
                    .items_center()
                    .px_4()
                    .gap_3()
                    .child(
                        // Play/Pause button
                        div()
                            .px_3()
                            .py_1()
                            .bg(rgb(0x2563eb))
                            .hover(|style| style.bg(rgb(0x1d4ed8)))
                            .rounded_md()
                            .text_color(rgb(0xffffff))
                            .text_xs
    fn render(&mut self, _window: &mut Window, cx: &mut Context<Self>) -> impl IntoElement {
        // Update playback controller
        let now = std::time::Instant::now();
        let delta_time = now.duration_since(self.last_update_time).as_secs_f64();
        self.last_update_time = now;
        self.playback_controller.update(delta_time);

        // Request refresh if playing
        if self.playback_controller.is_playing {
            cx.notify();
        }
        div()
            .size_full()
            .flex()
            .flex_col()
            .child(
                // Unified top bar with all options
                div()
                    .h(px(48.))
                    .bg(rgb(0x181818))
                    .flex()
                    .items_center()
                    .justify_between()
                    .px_4()
                    .border_b_1()
                    .border_color(rgb(0x2a2a2a))
                    .child(
                        // Left: App branding and navigation tabs
                        div()
                            .flex()
                            .items_center()
                            .gap_6()
                            .child(
                                div()
                                    .text_color(rgb(0xffffff))
                                    .font_weight(FontWeight::BOLD)
                                    .text_base()
                                    .child("CanView"),
                            )
                            .child(
                                div()
                                    .flex()
                                    .items_center()
                                    .gap_1()
                                    .child(
                                        div()
                                            .px_3()
                                            .py_1()
                                            .text_xs()
                                            .font_weight(FontWeight::MEDIUM)
                                            .cursor_pointer()
                                            .rounded(px(4.))
                                            .bg(if self.current_view == AppView::LogView {
                                                rgb(0x3b82f6)
                                            } else {
                                                rgb(0x2a2a2a)
                                            })
                                            .text_color(if self.current_view == AppView::LogView {
                                                rgb(0xffffff)
                                            } else {
                                                rgb(0x9ca3af)
                                            })
                                            .hover(|style| {
                                                if self.current_view != AppView::LogView {
                                                    style
                                                        .bg(rgb(0x374151))
                                                        .text_color(rgb(0xd1d5db))
                                                } else {
                                                    style
                                                }
                                            })
                                            .child("Logs"),
                                    )
                                    .child(
                                        div()
                                            .px_3()
                                            .py_1()
                                            .text_xs()
                                            .font_weight(FontWeight::MEDIUM)
                                            .cursor_pointer()
                                            .rounded(px(4.))
                                            .bg(if self.current_view == AppView::ConfigView {
                                                rgb(0x3b82f6)
                                            } else {
                                                rgb(0x2a2a2a)
                                            })
                                            .text_color(
                                                if self.current_view == AppView::ConfigView {
                                                    rgb(0xffffff)
                                                } else {
                                                    rgb(0x9ca3af)
                                                },
                                            )
                                            .hover(|style| {
                                                if self.current_view != AppView::ConfigView {
                                                    style
                                                        .bg(rgb(0x374151))
                                                        .text_color(rgb(0xd1d5db))
                                                } else {
                                                    style
                                                }
                                            })
                                            .child("Config"),
                                    )
                                    .child(
                                        div()
                                            .px_3()
                                            .py_1()
                                            .text_xs()
                                            .font_weight(FontWeight::MEDIUM)
                                            .cursor_pointer()
                                            .rounded(px(4.))
                                            .bg(if self.current_view == AppView::ChartView {
                                                rgb(0x3b82f6)
                                            } else {
                                                rgb(0x2a2a2a)
                                            })
                                            .text_color(
                                                if self.current_view == AppView::ChartView {
                                                    rgb(0xffffff)
                                                } else {
                                                    rgb(0x9ca3af)
                                                },
                                            )
                                            .hover(|style| {
                                                if self.current_view != AppView::ChartView {
                                                    style
                                                        .bg(rgb(0x374151))
                                                        .text_color(rgb(0xd1d5db))
                                                } else {
                                                    style
                                                }
                                            })
                                            .child("Charts"),
                                    ),
                            ),
                    )
                    .child(
                        // Center: Status and stats
                        div()
                            .flex()
                            .items_center()
                            .gap_4()
                            .child(
                                div()
                                    .text_xs()
                                    .text_color(rgb(0x6b7280))
                                    .child(self.status_msg.clone()),
                            )
                            .child(div().w(px(1.)).h(px(16.)).bg(rgb(0x374151)))
                            .child(
                                div()
                                    .flex()
                                    .items_center()
                                    .gap_3()
                                    .text_xs()
                                    .text_color(rgb(0x9ca3af))
                                    .child(format!("{} msgs", self.messages.len()))
                                    .child(format!("{} DBC", self.dbc_channels.len()))
                                    .child(format!("{} LIN", self.ldf_channels.len())),
                            ),
                    )
                    .child(
                        // Right: Action buttons
                        div()
                            .flex()
                            .items_center()
                            .gap_2()
                            .child(
                                div()
                                    .px_3()
                                    .py_1()
                                    .text_xs()
                                    .font_weight(FontWeight::MEDIUM)
                                    .text_color(rgb(0xffffff))
                                    .bg(rgb(0x059669))
                                    .rounded(px(4.))
                                    .cursor_pointer()
                                    .hover(|style| style.bg(rgb(0x047857)))
                                    .child("üìÇ Open BLF"),
                            )
                            .child(
                                div()
                                    .px_3()
                                    .py_1()
                                    .text_xs()
                                    .font_weight(FontWeight::MEDIUM)
                                    .text_color(rgb(0xffffff))
                                    .bg(rgb(0xd97706))
                                    .rounded(px(4.))
                                    .cursor_pointer()
                                    .hover(|style| style.bg(rgb(0xb45309)))
                                    .child("‚öôÔ∏è Load Config"),
                            )
                            .child(
                                div()
                                    .px_3()
                                    .py_1()
                                    .text_xs()
                                    .font_weight(FontWeight::MEDIUM)
                                    .text_color(rgb(0x9ca3af))
                                    .bg(rgb(0x374151))
                                    .rounded(px(4.))
                                    .cursor_pointer()
                                    .hover(|style| {
                                        style.bg(rgb(0x4b5563)).text_color(rgb(0xd1d5db))
                                    })
                                    .child("üíæ Export"),
                            ),
                    ),
            )
            .child(
                // Content area
                div().flex_1().bg(rgb(0x181818)).overflow_hidden().child({
                    let current_view = self.current_view.clone();
                    match current_view {
                        AppView::LogView => self.render_log_view().into_any_element(),
                        AppView::ConfigView => self.render_config_view().into_any_element(),
                        AppView::ChartView => self.render_chart_view().into_any_element(),
                    }
                }),
            )
    }
}

impl CanViewApp {
    fn render_log_view(&self) -> impl IntoElement {
        div()
            .size_full()
            .flex()
            .flex_col()
            .child(
                // Playback controls
                div()
                    .w_full()
                    .h(px(40.))
                    .bg(rgb(0x1a1a1a))
                    .border_b_1()
                    .border_color(rgb(0x2a2a2a))
                    .flex()
                    .items_center()
                    .px_4()
                    .gap_3()
                    .child(
                        // Play/Pause button
                        div()
                            .px_3()
                            .py_1()
                            .bg(rgb(0x2563eb))
                            .hover(|style| style.bg(rgb(0x1d4ed8)))
                            .rounded_md()
                            .text_color(rgb(0xffffff))
                            .text_xs()
                            .cursor_pointer()
                            .child(if self.playback_controller.is_playing {
                                "Pause"
                            } else {
                                "Play"
                            })
                            .child(""),
                    )
                    .child(
                        // Stop button
                        div()
                            .px_3()
                            .py_1()
                            .bg(rgb(0x6b7280))
                            .hover(|style| style.bg(rgb(0x4b5563)))
                            .rounded_md()
                            .text_color(rgb(0xffffff))
                            .text_xs()
                            .cursor_pointer()
                            .child("Stop")
                            .child(""),
                    )
                    .child(
                        // Time display
                        div().text_sm().text_color(rgb(0x9ca3af)).child(format!(
                            "{} / {}",
                            PlaybackController::format_time(self.playback_controller.current_time),
                            PlaybackController::format_time(self.playback_controller.end_time)
                        )),
                    )
                    .child(
                        // Speed control
                        div()
                            .flex()
                            .items_center()
                            .gap_2()
                            .child(div().text_xs().text_color(rgb(0x9ca3af)).child("Speed:"))
                            .child(
                                div().text_xs().text_color(rgb(0xd1d5db)).child(format!(
                                    "{:.1}x",
                                    self.playback_controller.playback_speed
                                )),
                            ),
                    )
                    .child(
                        // Speed adjustment buttons
                        div()
                            .flex()
                            .items_center()
                            .gap_1()
                            .child(
                                div()
                                    .px_2()
                                    .py_1()
                                    .bg(rgb(0x374151))
                                    .hover(|style| style.bg(rgb(0x4b5563)))
                                    .rounded_md()
                                    .text_color(rgb(0xffffff))
                                    .text_xs()
                                    .cursor_pointer()
                                    .child("0.5x")
                                    .child(""),
                            )
                            .child(
                                div()
                                    .px_2()
                                    .py_1()
                                    .bg(rgb(0x374151))
                                    .hover(|style| style.bg(rgb(0x4b5563)))
                                    .rounded_md()
                                    .text_color(rgb(0xffffff))
                                    .text_xs()
                                    .cursor_pointer()
                                    .child("1x")
                                    .child(""),
                            )
                            .child(
                                div()
                                    .px_2()
                                    .py_1()
                                    .bg(rgb(0x374151))
                                    .hover(|style| style.bg(rgb(0x4b5563)))
                                    .rounded_md()
                                    .text_color(rgb(0xffffff))
                                    .text_xs()
                                    .cursor_pointer()
                                    .child("2x")
                                    .child(""),
                            ),
                    )
                    .child(
                        div()
                            .flex_1()
                            .h(px(20.))
                            .bg(rgb(0x374151))
                            .rounded_md()
                            .cursor_pointer()
                            .relative()
                            .child(div().h_full().bg(rgb(0x2563eb)).rounded_md().w(relative({
                                let progress = if self.playback_controller.end_time > 0.0 {
                                    (self.playback_controller.current_time
                                        / self.playback_controller.end_time)
                                        .min(1.0)
                                } else {
                                    0.0
                                };
                                progress as f32
                            })))
                            .child(
                                div()
                                    .absolute()
                                    .top_0()
                                    .left_0()
                                    .w_full()
                                    .h_full()
                                    .flex()
                                    .items_center()
                                    .justify_center()
                                    .text_xs()
                                    .text_color(rgb(0xd1d5db))
                                    .child(if self.is_streaming_mode {
                                        "Streaming mode - Click to seek"
                                    } else {
                                        "Click to seek"
                                    }),
                            )
                            .child(""),
                    ),
            )
            .child(
                // Load more button for streaming mode
                if self.is_streaming_mode {
                    div()
                        .px_3()
                        .py_1()
                        .bg(rgb(0x059669))
                        .hover(|style| style.bg(rgb(0x047857)))
                        .rounded_md()
                        .text_color(rgb(0xffffff))
                        .text_xs()
                        .cursor_pointer()
                        .child("Load More")
                        .child("")
                } else {
                    div() // Empty div when not in streaming mode
                },
            )
            .child(
                // Zed-style header
                div()
                    .w_full()
                    .h(px(28.))
                    .bg(rgb(0x1f1f1f))
                    .border_b_1()
                    .border_color(rgb(0x2a2a2a))
                    .flex()
                    .items_center()
                    .text_xs()
                    .font_weight(FontWeight::MEDIUM)
                    .text_color(rgb(0x9ca3af))
                    .child(div().w(px(100.)).px_3().child("TIME"))
                    .child(div().w(px(40.)).px_2().child("CH"))
                    .child(div().w(px(50.)).px_2().child("TYPE"))
                    .child(div().w(px(70.)).px_2().child("ID"))
                    .child(div().w(px(40.)).px_2().child("DLC"))
                    .child(div().w(px(150.)).px_2().child("DATA"))
                    .child(div().flex_1().px_2().child("SIGNALS")),
            )
            .child(
                // Message list
                div().flex_1().overflow_y_hidden().child(
                    div().w_full().flex().flex_col().children(
                        if !self.playback_controller.messages.is_empty() {
                            // Use playback controller for filtered messages during playback
                            self.playback_controller
                                .get_visible_messages(500)
                                .into_iter()
                                .enumerate()
                                .map(|(i, msg)| self.render_message_row(msg, i))
                                .collect::<Vec<_>>()
                        } else {
                            // Fallback to all messages when not in playback mode
                            self.messages
                                .iter()
                                .take(500)
                                .enumerate()
                                .map(|(i, msg)| self.render_message_row(msg, i))
                                .collect::<Vec<_>>()
                        },
                    ),
                ),
            )
            .child(
                // Status panel
                div()
                    .w_full()
                    .h(px(80.))
                    .bg(rgb(0x1a1a1a))
                    .border_t_1()
                    .border_color(rgb(0x2a2a2a))
                    .flex()
                    .items_center()
                    .px_4()
                    .gap_6()
                    .child(
                        // File info section
                        div()
                            .flex()
                            .flex_col()
                            .gap_1()
                            .child(
                                div()
                                    .text_xs()
                                    .font_weight(FontWeight::MEDIUM)
                                    .text_color(rgb(0x9ca3af))
                                    .child("FILE INFO"),
                            )
                            .child(div().text_xs().text_color(rgb(0xd1d5db)).child(format!(
                                "Messages: {} | Mode: {}",
                                self.messages.len(),
                                if self.is_streaming_mode {
                                    "Streaming"
                                } else {
                                    "Normal"
                                }
                            ))),
                    )
                    .child(
                        // Playback info section
                        div()
                            .flex()
                            .flex_col()
                            .gap_1()
                            .child(
                                div()
                                    .text_xs()
                                    .font_weight(FontWeight::MEDIUM)
                                    .text_color(rgb(0x9ca3af))
                                    .child("PLAYBACK"),
                            )
                            .child(div().text_xs().text_color(rgb(0xd1d5db)).child(format!(
                                "Status: {} | Speed: {:.1}x | Progress: {:.1}%",
                                if self.playback_controller.is_playing {
                                    "Playing"
                                } else {
                                    "Paused"
                                },
                                self.playback_controller.playback_speed,
                                if self.playback_controller.end_time > 0.0 {
                                    (self.playback_controller.current_time
                                        / self.playback_controller.end_time)
                                        * 100.0
                                } else {
                                    0.0
                                }
                            ))),
                    )
                    .child(
                        // Statistics section
                        div()
                            .flex()
                            .flex_col()
                            .gap_1()
                            .child(
                                div()
                                    .text_xs()
                                    .font_weight(FontWeight::MEDIUM)
                                    .text_color(rgb(0x9ca3af))
                                    .child("STATISTICS"),
                            )
                            .child(div().text_xs().text_color(rgb(0xd1d5db)).child({
                                let visible_messages =
                                    if !self.playback_controller.messages.is_empty() {
                                        self.playback_controller.get_visible_messages(500).len()
                                    } else {
                                        self.messages.len().min(500)
                                    };
                                format!(
                                    "Visible: {} | Total Duration: {}",
                                    visible_messages,
                                    PlaybackController::format_time(
                                        self.playback_controller.end_time
                                    )
                                )
                            })),
                    )
                    .child(
                        // Status message
                        div().flex_1().flex().justify_end().child(
                            div()
                                .text_xs()
                                .text_color(rgb(0x9ca3af))
                                .child(self.status_msg.clone()),
                        ),
                    ),
            )
    }

    fn render_config_view(&self) -> impl IntoElement {
        div()
            .size_full()
            .p_6()
            .flex()
            .flex_col()
            .gap_4()
            .text_color(rgb(0xd1d5db))
            .child(
                div()
                    .text_lg()
                    .font_weight(FontWeight::MEDIUM)
                    .mb_4()
                    .text_color(rgb(0xffffff))
                    .child("Configuration"),
            )
            .child(
                div()
                    .p_4()
                    .bg(rgb(0x1f1f1f))
                    .border_1()
                    .border_color(rgb(0x2a2a2a))
                    .rounded(px(8.))
                    .flex()
                    .flex_col()
                    .gap_2()
                    .child(
                        div()
                            .text_sm()
                            .font_weight(FontWeight::MEDIUM)
                            .text_color(rgb(0xffffff))
                            .child("Status"),
                    )
                    .child(
                        div()
                            .text_xs()
                            .text_color(rgb(0x9ca3af))
                            .child(format!("Messages loaded: {}", self.messages.len())),
                    )
                    .child(
                        div()
                            .text_xs()
                            .text_color(rgb(0x9ca3af))
                            .child(format!("DBC channels: {}", self.dbc_channels.len())),
                    )
                    .child(
                        div()
                            .text_xs()
                            .text_color(rgb(0x9ca3af))
                            .child(format!("LIN channels: {}", self.ldf_channels.len())),
                    ),
            )
    }

    fn render_chart_view(&self) -> impl IntoElement {
        div()
            .size_full()
            .p_6()
            .flex()
            .flex_col()
            .gap_4()
            .text_color(rgb(0xd1d5db))
            .child(
                div()
                    .text_lg()
                    .font_weight(FontWeight::MEDIUM)
                    .mb_4()
                    .text_color(rgb(0xffffff))
                    .child("Analytics"),
            )
            .child(
                div()
                    .p_6()
                    .bg(rgb(0x1f1f1f))
                    .border_1()
                    .border_color(rgb(0x2a2a2a))
                    .rounded(px(8.))
                    .flex()
                    .flex_col()
                    .items_center()
                    .justify_center()
                    .gap_3()
                    .child(
                        div()
                            .text_sm()
                            .text_color(rgb(0x9ca3af))
                            .child("Chart visualization coming soon"),
                    )
                    .child(
                        div()
                            .text_xs()
                            .text_color(rgb(0x6b7280))
                            .child("Real-time signal analysis and plotting"),
                    ),
            )
    }
}

fn main() {
    env_logger::init();

    let app = Application::new();
    app.run(move |cx| {
        cx.spawn(async move |cx| {
            let options = get_window_options();
            cx.open_window(options, |_window, cx| cx.new(|_cx| CanViewApp::new()))?;
            Ok::<_, anyhow::Error>(())
        })
        .detach();
    });
}
}
