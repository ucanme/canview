use blf::{read_blf_from_file, LogObject, StreamingBlfReader};
use gpui::{prelude::*, *};
use parser::dbc::{DbcDatabase, DbcParser};
use parser::ldf::{LdfDatabase, LdfParser};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::path::PathBuf;

use std::time::{Duration, Instant};

// 定义枚举和结构体
#[derive(Debug, Serialize, Deserialize, Clone, PartialEq, Copy)]
enum ChannelType {
    CAN,
    LIN,
}

#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)]
struct LibraryVersion {
    name: String,
    path: String,
    date: String,
}

#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)]
struct SignalLibrary {
    id: String,
    name: String,
    versions: Vec<LibraryVersion>,
}

#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)]
struct ChannelMapping {
    #[serde(default = "default_channel_type")]
    channel_type: ChannelType,
    #[serde(alias = "channel")]
    channel_id: u16,
    #[serde(default)]
    path: String,
    #[serde(default)]
    description: String,
    library_id: Option<String>,
    version_name: Option<String>,
}

fn default_channel_type() -> ChannelType {
    ChannelType::CAN
}

#[derive(Debug, Serialize, Deserialize, Clone, Default)]
struct AppConfig {
    libraries: Vec<SignalLibrary>,
    mappings: Vec<ChannelMapping>,
    active_library_id: Option<String>,
    active_version_name: Option<String>,
}

#[derive(Debug, Clone, PartialEq)]
enum AppView {
    LogView,
    ConfigView,
    ChartView,
}

// 定义我们的根视图结构
struct CanViewApp {
    current_view: AppView,
    messages: Vec<LogObject>,
    status_msg: SharedString,
    dbc_channels: HashMap<u16, DbcDatabase>,
    ldf_channels: HashMap<u16, LdfDatabase>,
    app_config: AppConfig,
    selected_signals: Vec<String>,
    start_time: Option<chrono::NaiveDateTime>,
    config_dir: Option<PathBuf>,
    config_file_path: Option<PathBuf>,
    // Tracks whether the window is currently maximized (used for UI state)
    is_maximized: bool,
    // Whether the app is in streaming mode (used in the status area)
    is_streaming_mode: bool,

    // Playback related fields
    is_playing: bool,
    playback_speed: f64,
    current_playback_time: Duration,
    playback_start_time: Option<Instant>,
    last_playback_update: Option<Instant>,
    total_duration: Duration,
    current_file_path: Option<PathBuf>,
    streaming_reader: Option<StreamingBlfReader>,
    playback_messages: Vec<LogObject>,
    playback_position: usize,
}

impl CanViewApp {
    fn new() -> Self {
        let mut app = Self {
            current_view: AppView::LogView,
            messages: Vec::new(),
            status_msg: "Ready".into(),
            dbc_channels: HashMap::new(),
            ldf_channels: HashMap::new(),
            app_config: AppConfig::default(),
            selected_signals: Vec::new(),
            start_time: None,
            config_dir: None,
            config_file_path: None,
            // Default window/app states
            is_maximized: false,
            is_streaming_mode: false,

            // Playback related fields
            is_playing: false,
            playback_speed: 1.0,
            current_playback_time: Duration::from_nanos(0),
            playback_start_time: None,
            last_playback_update: None,
            total_duration: Duration::from_nanos(0),
            current_file_path: None,
            streaming_reader: None,
            playback_messages: Vec::new(),
            playback_position: 0,
        };

        // 启动时加载配置
        app.load_startup_config();
        app
    }

    fn load_startup_config(&mut self) {
        let path = PathBuf::from("multi_channel_config.json");
        if path.exists() {
            self.status_msg = "Found saved config, loading...".into();
            if let Ok(content) = std::fs::read_to_string(&path) {
                match serde_json::from_str::<AppConfig>(&content) {
                    Ok(mut config) => {
                        // Fill in missing paths from library versions for legacy configs
                        for mapping in &mut config.mappings {
                            if mapping.path.is_empty() {
                                if let Some(lib_id) = &mapping.library_id {
                                    if let Some(version_name) = &mapping.version_name {
                                        if let Some(library) =
                                            config.libraries.iter().find(|l| l.id == *lib_id)
                                        {
                                            if let Some(version) = library
                                                .versions
                                                .iter()
                                                .find(|v| v.name == *version_name)
                                            {
                                                mapping.path = version.path.clone();
                                            }
                                        }
                                    }
                                }
                            }
                        }

                        self.app_config = config.clone();
                        self.config_dir = Some(
                            path.parent()
                                .unwrap_or(std::path::Path::new("."))
                                .to_path_buf(),
                        );
                        self.config_file_path = Some(path);
                        self.status_msg = "Configuration loaded.".into();

                        // Auto-Apply if Active Version Exists
                        if let (Some(l_id), Some(v_name)) =
                            (&config.active_library_id, &config.active_version_name)
                        {
                            self.apply_active_version(l_id, v_name);
                        }
                    }
                    Err(e) => {
                        self.status_msg =
                            format!("Config load error: {}. Using default config.", e).into();
                        // Initialize with empty config instead of failing
                        self.app_config = AppConfig::default();
                    }
                }
            }
        } else {
            self.status_msg = "Ready - GPUI version initialized".into();
        }
    }

    fn calculate_total_duration(&self) -> Duration {
        if self.messages.is_empty() {
            return Duration::from_nanos(0);
        }

        // Find the maximum timestamp among all messages
        let max_timestamp = self
            .messages
            .iter()
            .filter_map(|msg| match msg {
                LogObject::CanMessage(can_msg) => Some(can_msg.header.object_time_stamp),
                LogObject::LinMessage(lin_msg) => Some(lin_msg.header.object_time_stamp),
                _ => None,
            })
            .max()
            .unwrap_or(0);

        Duration::from_nanos(max_timestamp)
    }

    fn toggle_playback(&mut self, window: &mut Window, cx: &mut Context<Self>) {
        if self.messages.is_empty() {
            self.status_msg = "No messages to play. Load a BLF file first.".into();
            return;
        }

        if self.is_playing {
            // Pause playback
            self.is_playing = false;
            self.status_msg = "Playback paused".into();
        } else {
            // Start or resume playback
            if self.current_playback_time >= self.total_duration {
                // If we've reached the end, reset to beginning
                self.current_playback_time = Duration::from_nanos(0);
                self.playback_position = 0;
            }

            self.is_playing = true;
            self.playback_start_time = Some(Instant::now());
            self.last_playback_update = Some(Instant::now());
            self.status_msg = "Playback started".into();

            // Start the playback loop (use window-specific context for async ops)
            self.start_playback_loop(window, cx);
        }
    }

    fn stop_playback(&mut self, _cx: &mut Context<Self>) {
        self.is_playing = false;
        self.current_playback_time = Duration::from_nanos(0);
        self.playback_position = 0;
        self.playback_start_time = None;
        self.last_playback_update = None;
        self.status_msg = "Playback stopped".into();
    }

    fn set_playback_speed(&mut self, speed: f64) {
        self.playback_speed = speed;
        self.status_msg = format!("Playback speed: {:.1}x", speed).into();
    }

    fn seek_to_time(&mut self, time: Duration) {
        if self.messages.is_empty() {
            return;
        }

        // Find the position closest to the requested time
        let target_nanos = time.as_nanos() as u64;

        // Find first message with timestamp >= target time
        self.playback_position = self
            .messages
            .iter()
            .position(|msg| match msg {
                LogObject::CanMessage(can_msg) => can_msg.header.object_time_stamp >= target_nanos,
                LogObject::LinMessage(lin_msg) => lin_msg.header.object_time_stamp >= target_nanos,
                _ => false,
            })
            .unwrap_or(self.messages.len());

        self.current_playback_time = time;
        self.status_msg = format!("Seeked to {:.2}s", time.as_secs_f64()).into();
    }

    fn update_playback(&mut self) {
        if !self.is_playing || self.messages.is_empty() {
            return;
        }

        if let (Some(_start_time), Some(last_update)) =
            (self.playback_start_time, self.last_playback_update)
        {
            let elapsed_real_time = last_update.elapsed();
            let elapsed_playback_time =
                Duration::from_secs_f64(elapsed_real_time.as_secs_f64() * self.playback_speed);

            let new_playback_time = self.current_playback_time + elapsed_playback_time;

            // Check if we've reached the end
            if new_playback_time >= self.total_duration {
                self.is_playing = false;
                self.current_playback_time = self.total_duration;
                self.status_msg = "Playback finished".into();
                return;
            }

            self.current_playback_time = new_playback_time;
            self.last_playback_update = Some(Instant::now());

            // Update playback position based on current time
            let target_nanos = self.current_playback_time.as_nanos() as u64;
            self.playback_position = self
                .messages
                .iter()
                .take(self.messages.len())
                .position(|msg| match msg {
                    LogObject::CanMessage(can_msg) => {
                        can_msg.header.object_time_stamp >= target_nanos
                    }
                    LogObject::LinMessage(lin_msg) => {
                        lin_msg.header.object_time_stamp >= target_nanos
                    }
                    _ => false,
                })
                .unwrap_or(self.messages.len());
        }
    }

    fn apply_active_version(&mut self, library_id: &str, version_name: &str) {
        if let Some(parent) = &self.config_dir {
            self.status_msg = format!("Applying active version: {}...", version_name).into();

            self.dbc_channels.clear();
            self.ldf_channels.clear();

            for mapping in &self.app_config.mappings {
                if mapping.library_id.as_ref() == Some(&library_id.to_string())
                    && mapping.version_name.as_ref() == Some(&version_name.to_string())
                {
                    // Try to find the actual file path from library versions
                    let file_path = if !mapping.path.is_empty() {
                        mapping.path.clone()
                    } else if let Some(library) = self
                        .app_config
                        .libraries
                        .iter()
                        .find(|l| l.id == library_id)
                    {
                        if let Some(version) =
                            library.versions.iter().find(|v| v.name == version_name)
                        {
                            version.path.clone()
                        } else {
                            continue;
                        }
                    } else {
                        continue;
                    };

                    let full_path = parent.join(&file_path);
                    if let Ok(content) = std::fs::read_to_string(&full_path) {
                        match mapping.channel_type {
                            ChannelType::CAN => {
                                let parser = DbcParser::new();
                                if let Ok(db) = parser.parse(&content) {
                                    self.dbc_channels.insert(mapping.channel_id, db);
                                }
                            }
                            ChannelType::LIN => {
                                let parser = LdfParser::new();
                                if let Ok(db) = parser.parse(&content) {
                                    self.ldf_channels.insert(mapping.channel_id, db);
                                }
                            }
                        }
                    }
                }
            }
            self.status_msg = format!(
                "Loaded {} DBC and {} LIN channels",
                self.dbc_channels.len(),
                self.ldf_channels.len()
            )
            .into();
        }
    }

    fn open_blf_file(&mut self, cx: &mut Context<Self>) {
        // Use synchronous file dialog for simplicity
        if let Some(path) = rfd::FileDialog::new()
            .add_filter("BLF Files", &["blf", "bin"])
            .pick_file()
        {
            self.status_msg = "Loading BLF...".into();
            match read_blf_from_file(&path) {
                Ok(result) => {
                    self.status_msg =
                        format!("Loaded BLF: {} objects", result.objects.len()).into();

                    // Parse start time
                    let st = result.file_stats.measurement_start_time.clone();
                    let date_opt = chrono::NaiveDate::from_ymd_opt(
                        st.year as i32,
                        st.month as u32,
                        st.day as u32,
                    );
                    let time_opt = chrono::NaiveTime::from_hms_milli_opt(
                        st.hour as u32,
                        st.minute as u32,
                        st.second as u32,
                        st.milliseconds as u32,
                    );

                    if let (Some(date), Some(time)) = (date_opt, time_opt) {
                        self.start_time = Some(chrono::NaiveDateTime::new(date, time));
                    } else {
                        self.start_time = None;
                    }

                    self.messages = result.objects;

                    // Calculate total duration for playback
                    self.total_duration = self.calculate_total_duration();

                    // Reset playback state
                    self.is_playing = false;
                    self.current_playback_time = Duration::from_nanos(0);
                    self.playback_position = 0;
                    self.current_file_path = Some(path);

                    self.status_msg = format!(
                        "Loaded BLF: {} objects, duration: {:.2}s",
                        self.messages.len(),
                        self.total_duration.as_secs_f64()
                    )
                    .into();

                    // Debug: log object count and a few sample objects for inspection
                    log::debug!(
                        "BLF loaded: {} objects, duration: {:.2}s",
                        self.messages.len(),
                        self.total_duration.as_secs_f64()
                    );
                    for (i, obj) in self.messages.iter().take(5).enumerate() {
                        match obj {
                            LogObject::CanMessage(can_msg) => {
                                log::debug!(
                                    "Sample[{}]: CAN ch={} id=0x{:X} dlc={} ts={}",
                                    i,
                                    can_msg.channel,
                                    can_msg.id,
                                    can_msg.dlc,
                                    can_msg.header.object_time_stamp
                                );
                            }
                            LogObject::LinMessage(lin_msg) => {
                                log::debug!(
                                    "Sample[{}]: LIN ch={} id=0x{:X} dlc={} ts={}",
                                    i,
                                    lin_msg.channel,
                                    lin_msg.id,
                                    lin_msg.dlc,
                                    lin_msg.header.object_time_stamp
                                );
                            }
                            other => {
                                log::debug!("Sample[{}]: other {:?}", i, other);
                            }
                        }
                    }

                    // Notify the UI context so the view re-renders with the loaded messages
                    cx.notify();
                }
                Err(e) => {
                    self.status_msg = format!("Error: {:?}", e).into();
                    // Log error for debugging
                    log::error!("Failed to load BLF: {:?}", e);
                    // Notify the UI that an error occurred / status changed
                    cx.notify();
                }
            }
        }
    }

    fn load_config(&mut self, _cx: &mut Context<Self>) {
        if let Some(path) = rfd::FileDialog::new()
            .add_filter("Config Files", &["json"])
            .pick_file()
        {
            self.status_msg = "Loading config...".into();
            if let Ok(content) = std::fs::read_to_string(&path) {
                match serde_json::from_str::<AppConfig>(&content) {
                    Ok(config) => {
                        self.app_config = config;
                        self.config_dir = Some(
                            path.parent()
                                .unwrap_or(std::path::Path::new("."))
                                .to_path_buf(),
                        );
                        self.config_file_path = Some(path);
                        self.status_msg = "Configuration loaded successfully".into();
                    }
                    Err(e) => {
                        self.status_msg = format!("Config Error: {}", e).into();
                    }
                }
            }
        }
    }

    fn get_timestamp_string(&self, timestamp: u64) -> String {
        if let Some(start) = &self.start_time {
            let msg_time = *start + chrono::Duration::nanoseconds(timestamp as i64);
            msg_time.format("%H:%M:%S%.3f").to_string()
        } else {
            format!("{:.3}", timestamp as f64 / 1000000.0)
        }
    }

    fn render_message_row(&self, msg: &LogObject, index: usize) -> impl IntoElement {
        let (time_str, channel_id, msg_type, id_str, dlc_str, data_str, signals_str) = match msg {
            LogObject::CanMessage(can_msg) => {
                let timestamp = can_msg.header.object_time_stamp;
                let time_str = self.get_timestamp_string(timestamp);
                let data_hex = can_msg
                    .data
                    .iter()
                    .take(can_msg.dlc as usize)
                    .map(|b| format!("{:02X}", b))
                    .collect::<Vec<_>>()
                    .join(" ");
                let signals = if let Some(db) = self.dbc_channels.get(&can_msg.channel) {
                    if let Some(message) = db.messages.get(&can_msg.id) {
                        message
                            .signals
                            .iter()
                            .map(|(name, _signal)| {
                                // Simplified signal extraction for now
                                format!("{}=?", name)
                            })
                            .collect::<Vec<_>>()
                            .join(", ")
                    } else {
                        String::new()
                    }
                } else {
                    String::new()
                };

                (
                    time_str,
                    can_msg.channel,
                    "CAN".to_string(),
                    format!("0x{:03X}", can_msg.id),
                    can_msg.dlc.to_string(),
                    data_hex,
                    signals,
                )
            }
            LogObject::LinMessage(lin_msg) => {
                let timestamp = lin_msg.header.object_time_stamp;
                let time_str = self.get_timestamp_string(timestamp);
                let data_hex = lin_msg
                    .data
                    .iter()
                    .take(lin_msg.dlc as usize)
                    .map(|b| format!("{:02X}", b))
                    .collect::<Vec<_>>()
                    .join(" ");

                (
                    time_str,
                    lin_msg.channel,
                    "LIN".to_string(),
                    format!("0x{:02X}", lin_msg.id),
                    lin_msg.dlc.to_string(),
                    data_hex,
                    String::new(), // LIN signals parsing not implemented yet
                )
            }
            _ => (
                "Unknown".to_string(),
                0,
                "Other".to_string(),
                "-".to_string(),
                "-".to_string(),
                "-".to_string(),
                String::new(),
            ),
        };

        let bg_color = if index % 2 == 0 {
            rgb(0x181818)
        } else {
            rgb(0x1a1a1a)
        };

        div()
            .flex()
            .w_full()
            .min_h(px(22.))
            .bg(bg_color)
            .border_b_1()
            .border_color(rgb(0x2a2a2a))
            .items_center()
            .text_xs()
            .text_color(rgb(0xd1d5db))
            .hover(|style| style.bg(rgb(0x1f2937)))
            .cursor_pointer()
            .child(
                div()
                    .w(px(100.))
                    .px_3()
                    .py_1()
                    .text_color(rgb(0x9ca3af))
                    .child(time_str),
            )
            .child(
                div()
                    .w(px(40.))
                    .px_2()
                    .py_1()
                    .text_color(rgb(0x60a5fa))
                    .child(channel_id.to_string()),
            )
            .child(
                div()
                    .w(px(50.))
                    .px_2()
                    .py_1()
                    .text_color(rgb(0x34d399))
                    .child(msg_type),
            )
            .child(
                div()
                    .w(px(70.))
                    .px_2()
                    .py_1()
                    .text_color(rgb(0xfbbf24))
                    .child(id_str),
            )
            .child(div().w(px(40.)).px_2().py_1().child(dlc_str))
            .child(
                div()
                    .w(px(150.))
                    .px_2()
                    .py_1()
                    .text_color(rgb(0xa78bfa))
                    .child(data_str),
            )
            .child(
                div()
                    .flex_1()
                    .px_2()
                    .py_1()
                    .text_color(rgb(0x9ca3af))
                    .child(signals_str),
            )
    }
}

// 实现视图

impl Render for CanViewApp {
    fn render(&mut self, _window: &mut Window, cx: &mut Context<Self>) -> impl IntoElement {
        // Use context listeners for button handlers instead of capturing weak handles
        div()
            .size_full()
            .flex()
            .flex_col()
            .child(
                div()
                    .h(px(48.))
                    .bg(rgb(0x181818))
                    .flex()
                    .items_center()
                    .justify_between()
                    .px_4()
                    .border_b_1()
                    .border_color(rgb(0x2a2a2a))
                    // Start a native window move on left-button down (works on Wayland/X11; Windows will honor the drag area via hit-testing).
                    .on_mouse_down(gpui::MouseButton::Left, |_event, window, _app| {
                        window.start_window_move();
                    })
                    .child(
                        // Left + center in a single drag region
                        div()
                            .flex_1()
                            .flex()
                            .items_center()
                            .justify_between()
                            .window_control_area(WindowControlArea::Drag)
                            .child(
                                div()
                                    .flex()
                                    .items_center()
                                    .gap_6()
                                    .child(div().text_color(rgb(0xffffff)).font_weight(FontWeight::BOLD).text_base().child("CanView"))
                                    .child(
                                        div()
                                            .flex()
                                            .items_center()
                                            .gap_1()
                                            .child(div().px_3().py_1().text_xs().font_weight(FontWeight::MEDIUM).cursor_pointer().rounded(px(4.)).child("Logs"))
                                            .child(div().px_3().py_1().text_xs().font_weight(FontWeight::MEDIUM).cursor_pointer().rounded(px(4.)).child("Config"))
                                            .child(div().px_3().py_1().text_xs().font_weight(FontWeight::MEDIUM).cursor_pointer().rounded(px(4.)).child("Analytics"))
                                    )
                            )
                            .child(
                                div()
                                    .flex()
                                    .items_center()
                                    .gap_4()
                                    .child(div().text_xs().text_color(rgb(0x6b7280)).child(self.status_msg.clone()))
                                    .child(div().w(px(1.)).h(px(16.)).bg(rgb(0x374151)))
                                    .child(
                                        div()
                                            .flex()
                                            .items_center()
                                            .gap_3()
                                            .text_xs()
                                            .text_color(rgb(0x9ca3af))
                                            .child(format!("{} msgs", self.messages.len()))
                                            .child(format!("{} DBC", self.dbc_channels.len()))
                                            .child(format!("{} LIN", self.ldf_channels.len())),
                                    ),
                            ),
                    )
                    .child(
                        // Minimal right controls (keep close button so users can quit)
                        div()
                            .flex()
                            .items_center()
                            .gap_2()
                            .child(
                                div()
                                    .w(px(32.))
                                    .h(px(32.))
                                    .flex()
                                    .items_center()
                                    .justify_center()
                                    .cursor_pointer()
                                    .hover(|style| style.bg(rgb(0xdc2626)))
                                    .child(div().text_sm().text_color(rgb(0x9ca3af)).child("×"))
                                    .on_mouse_down(gpui::MouseButton::Left, |_event, window, _app| {
                                        window.remove_window();
                                    }),
                            ),
                    )

                            .child(
                                div()
                                    .w(px(32.))
                                    .h(px(32.))
                                    .flex()
                                    .items_center()
                                    .justify_center()
                                    .cursor_pointer()
                                    .hover(|style| style.bg(rgb(0xdc2626)))
                                    .child(div().text_sm().text_color(rgb(0x9ca3af)).child("×"))
                                    .on_mouse_down(
                                        gpui::MouseButton::Left,
                                        |_event, window, _app| {
                                            window.remove_window();
                                        },
                                    )
                            ),
            })

.child(
    // Content area
    div()
        .flex_1()
        .bg(rgb(0x181818))
                    .overflow_hidden()
                    .child(match self.current_view {
                        AppView::LogView => self.render_log_view().into_any_element(),
                        AppView::ConfigView => self.render_config_view().into_any_element(),
                        AppView::ChartView => self.render_chart_view().into_any_element(),
                    }),
            )
            .child(
                // Zed-style status bar at bottom
                div()
                    .h(px(24.))
                    .bg(rgb(0x1e1e1e))
                    .border_t_1()
                    .border_color(rgb(0x2a2a2a))
                    .flex()
                    .items_center()
                    .justify_between()
                    .px_3()
                    .text_xs()
                    .text_color(rgb(0x9ca3af))
                    .child(
                        // Left: File info and playback controls
                        div()
                            .flex()
                            .items_center()
                            .gap_3()
                            .child(div().child(format!("{} messages", self.messages.len())))
                            .child(div().child(format!("{} DBC channels", self.dbc_channels.len())))
                            .child(div().child(format!("{} LIN channels", self.ldf_channels.len())))
                            .child(div().child(format!(
                                "Playback: {:.2}s / {:.2}s",
                                self.current_playback_time.as_secs_f64(),
                                self.total_duration.as_secs_f64()
                            )))
                            .child(div().child(format!("Speed: {:.1}x", self.playback_speed))),
                    )
                    .child(
                        // Right: Status
                        div()
                            .flex()
                            .items_center()
                            .gap_3()
                            .child(div().child(if self.is_streaming_mode {
                                "Streaming Mode"
                            } else {
                                "Normal Mode"
                            }))
                            .child(div().child(self.status_msg.clone())),
                    ),
            )
    }
}

impl CanViewApp {
    fn render_log_view(&self) -> impl IntoElement {
        // Update playback if currently playing
        // This will be handled by the main render loop

        // Filter messages based on playback time if in playback mode
        let messages_to_display = if self.is_playing {
            let current_time_nanos = self.current_playback_time.as_nanos() as u64;
            self.messages
                .iter()
                .filter(|msg| match msg {
                    LogObject::CanMessage(can_msg) => {
                        can_msg.header.object_time_stamp <= current_time_nanos
                    }
                    LogObject::LinMessage(lin_msg) => {
                        lin_msg.header.object_time_stamp <= current_time_nanos
                    }
                    _ => true,
                })
                .take(500) // Limit to 500 messages for performance
                .collect::<Vec<_>>()
        } else {
            // Show all messages when not in playback mode
            self.messages.iter().take(500).collect()
        };
        div()
            .size_full()
            .flex()
            .flex_col()
            .child(
                // Zed-style header
                div()
                    .w_full()
                    .h(px(28.))
                    .bg(rgb(0x1f1f1f))
                    .border_b_1()
                    .border_color(rgb(0x2a2a2a))
                    .flex()
                    .items_center()
                    .text_xs()
                    .font_weight(FontWeight::MEDIUM)
                    .text_color(rgb(0x9ca3af))
                    .child(div().w(px(100.)).px_3().child("TIME"))
                    .child(div().w(px(40.)).px_2().child("CH"))
                    .child(div().w(px(50.)).px_2().child("TYPE"))
                    .child(div().w(px(70.)).px_2().child("ID"))
                    .child(div().w(px(40.)).px_2().child("DLC"))
                    .child(div().w(px(150.)).px_2().child("DATA"))
                    .child(div().flex_1().px_2().child("SIGNALS")),
            )
            .child(
                // Message list
                div().flex_1().overflow_y_hidden().child(
                    div().w_full().flex().flex_col().children(
                        messages_to_display
                            .iter()
                            .enumerate()
                            .map(|(i, msg)| self.render_message_row(msg, i)),
                    ),
                ),
            )
    }

    fn render_config_view(&self) -> impl IntoElement {
        div()
            .size_full()
            .p_6()
            .flex()
            .flex_col()
            .gap_4()
            .text_color(rgb(0xd1d5db))
            .child(
                div()
                    .text_lg()
                    .font_weight(FontWeight::MEDIUM)
                    .mb_4()
                    .text_color(rgb(0xffffff))
                    .child("Configuration"),
            )
            .child(
                div()
                    .p_4()
                    .bg(rgb(0x1f1f1f))
                    .border_1()
                    .border_color(rgb(0x2a2a2a))
                    .rounded(px(8.))
                    .flex()
                    .flex_col()
                    .gap_2()
                    .child(
                        div()
                            .text_sm()
                            .font_weight(FontWeight::MEDIUM)
                            .text_color(rgb(0xffffff))
                            .child("Status"),
                    )
                    .child(
                        div()
                            .text_xs()
                            .text_color(rgb(0x9ca3af))
                            .child(format!("Messages loaded: {}", self.messages.len())),
                    )
                    .child(
                        div()
                            .text_xs()
                            .text_color(rgb(0x9ca3af))
                            .child(format!("DBC channels: {}", self.dbc_channels.len())),
                    )
                    .child(
                        div()
                            .text_xs()
                            .text_color(rgb(0x9ca3af))
                            .child(format!("LIN channels: {}", self.ldf_channels.len())),
                    ),
            )
    }

    fn render_chart_view(&self) -> impl IntoElement {
        div()
            .size_full()
            .p_6()
            .flex()
            .flex_col()
            .gap_4()
            .text_color(rgb(0xd1d5db))
            .child(
                div()
                    .text_lg()
                    .font_weight(FontWeight::MEDIUM)
                    .mb_4()
                    .text_color(rgb(0xffffff))
                    .child("Analytics"),
            )
            .child(
                div()
                    .p_6()
                    .bg(rgb(0x1f1f1f))
                    .border_1()
                    .border_color(rgb(0x2a2a2a))
                    .rounded(px(8.))
                    .flex()
                    .flex_col()
                    .items_center()
                    .justify_center()
                    .gap_3()
                    .child(
                        div()
                            .text_sm()
                            .text_color(rgb(0x9ca3af))
                            .child("Chart visualization coming soon"),
                    )
                    .child(
                        div()
                            .text_xs()
                            .text_color(rgb(0x6b7280))
                            .child("Real-time signal analysis and plotting"),
                    ),
            )
    }

    fn start_playback_loop(&mut self, _window: &mut Window, _cx: &mut Context<Self>) {
        // Async playback loop disabled to avoid lifetime/async compile errors.
        // Playback updates will continue to work when `update_playback` is invoked
        // synchronously (e.g., from UI event handlers or a future refactor).
    }
}

fn main() {
    env_logger::init();

    let app = Application::new();
    app.run(move |cx| {
        cx.spawn(async move |cx| {
            let options = WindowOptions {
                window_bounds: Some(WindowBounds::Windowed(Bounds {
                    origin: Point::new(px(200.0), px(150.0)),
                    size: gpui::Size {
                        width: px(1600.0),
                        height: px(1000.0),
                    },
                })),
                titlebar: Some(TitlebarOptions {
                    title: None,
                    appears_transparent: true,
                    traffic_light_position: Some(Point::new(px(12.0), px(12.0))),
                }),

                ..Default::default()
            };
            cx.open_window(options, |_window, cx| cx.new(|_cx| CanViewApp::new()))?;
            Ok::<_, anyhow::Error>(())
        })
        .detach();
    });
}
