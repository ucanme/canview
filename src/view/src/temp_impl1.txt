impl CanViewApp {
    fn new() -> Self {
        // 启动时加载配�?        app.load_startup_config();
        Self {
            current_view: AppView::LogView,
            messages: Vec::new(),
            status_msg: "Ready".into(),
            dbc_channels: HashMap::new(),
            ldf_channels: HashMap::new(),
            app_config: AppConfig::default(),
            selected_signals: Vec::new(),
            start_time: None,
            config_dir: None,
            config_file_path: None,
            // Default window/app states
            is_maximized: false,
            is_streaming_mode: false,
            saved_window_bounds: None,
            display_bounds: None,
            // Initialize uniform list scroll handle
            list_scroll_handle: gpui::UniformListScrollHandle::new(),
            // Initialize scrollbar drag state
            scrollbar_drag_state: None,
            // Initialize scroll offset
            scroll_offset: px(0.0),
            // Initialize list container height (will be updated dynamically)
            list_container_height: 850.0,
            // Default to decimal ID display
            id_display_decimal: true,
            // ID filter: None means show all messages
            id_filter: None,
            id_filter_text: "".into(),
            // Hide ID filter input dialog by default
            show_id_filter_input: false,
            // Initialize filter scroll offset
            filter_scroll_offset: px(0.0),
            // Initialize filter scroll handle
            filter_scroll_handle: gpui::UniformListScrollHandle::new(),
            // Initialize mouse tracking
            mouse_over_filter_dropdown: false,
            dropdown_just_opened: false,
            // Channel filter
            channel_filter: None,
            channel_filter_text: "".into(),
            show_channel_filter_input: false,
            channel_filter_scroll_offset: px(0.0),
            channel_filter_scroll_handle: gpui::UniformListScrollHandle::new(),
            // Library management
            library_manager: app::LibraryManager::new(),
            selected_library_id: None,
            new_library_name: String::new(),
            library_cursor_position: 0,
            library_versions_expanded: true,
            show_version_input: false,
            new_version_name: String::new(),
            new_version_cursor_position: 0,
        }
    }

    fn load_startup_config(&mut self) {
        let path = PathBuf::from("multi_channel_config.json");
        if path.exists() {
            self.status_msg = "Found saved config, loading...".into();
            if let Ok(content) = std::fs::read_to_string(&path) {
                match serde_json::from_str::<AppConfig>(&content) {
                    Ok(config) => {
                        self.app_config = config.clone();
                        self.config_dir = Some(
                            path.parent()
                                .unwrap_or(std::path::Path::new("../../../../.."))
                                .to_path_buf(),
                        );
                        self.config_file_path = Some(path);
                        self.status_msg = "Configuration loaded.".into();
                    }
                    Err(e) => {
                        self.status_msg =
                            format!("Config load error: {}. Using default config.", e).into();
                        // Initialize with empty config instead of failing
                        self.app_config = AppConfig::default();
                    }
                }
            }
        } else {
            self.status_msg = "Ready - GPUI version initialized".into();
        }
    }

    fn apply_blf_result(&mut self, result: anyhow::Result<BlfResult>) {
        match result {
            Ok(result) => {
                self.status_msg = format!("Loaded BLF: {} objects", result.objects.len()).into();

                // Parse start time
                let st = result.file_stats.measurement_start_time.clone();
                let date_opt =
                    chrono::NaiveDate::from_ymd_opt(st.year as i32, st.month as u32, st.day as u32);
                let time_opt = chrono::NaiveTime::from_hms_milli_opt(
                    st.hour as u32,
                    st.minute as u32,
                    st.second as u32,
                    st.milliseconds as u32,
                );

                if let (Some(date), Some(time)) = (date_opt, time_opt) {
                    self.start_time = Some(chrono::NaiveDateTime::new(date, time));
                } else {
                    self.start_time = None;
                }

                self.messages = result.objects;
            }
            Err(e) => {
                self.status_msg = format!("Error: {:?}", e).into();
            }
        }
    }

    fn load_config(&mut self, _cx: &mut Context<Self>) {
        if let Some(path) = rfd::FileDialog::new()
            .add_filter("Config Files", &["json"])
            .pick_file()
        {
            self.status_msg = "Loading config...".into();
            if let Ok(content) = std::fs::read_to_string(&path) {
                match serde_json::from_str::<AppConfig>(&content) {
                    Ok(config) => {
                        self.app_config = config;
                        self.config_dir = Some(
                            path.parent()
                                .unwrap_or(std::path::Path::new("../../../../.."))
                                .to_path_buf(),
                        );
                        self.config_file_path = Some(path);
                        self.status_msg = "Configuration loaded successfully".into();
                    }
                    Err(e) => {
                        self.status_msg = format!("Config Error: {}", e).into();
                    }
                }
            }
        }
    }

    #[allow(dead_code)]
    fn get_timestamp_string(&self, timestamp: u64) -> String {
        if let Some(start) = &self.start_time {
            let msg_time = *start + chrono::Duration::nanoseconds(timestamp as i64);
            // Format: YYYY-MM-DD HH:MM:SS.mmmmmm (microseconds)
            msg_time.format("%Y-%m-%d %H:%M:%S%.6f").to_string()
        } else {
            // If no start time, show nanoseconds as seconds with microsecond precision
            format!("{:.6}", timestamp as f64 / 1_000_000_000.0)
        }
    }

    #[allow(dead_code)]
    fn render_message_row(&self, msg: &LogObject, index: usize) -> impl IntoElement {
        let (time_str, channel_id, msg_type, id_str, dlc_str, data_str, signals_str) = match msg {
            LogObject::CanMessage(can_msg) => {
                let timestamp = can_msg.header.object_time_stamp;
                let time_str = self.get_timestamp_string(timestamp);
                let actual_data_len = can_msg.data.len().min(can_msg.dlc as usize);
                let data_hex = can_msg
                    .data
                    .iter()
                    .take(actual_data_len)
                    .map(|b| format!("{:02X}", b))
                    .collect::<Vec<_>>()
                    .join(" ");
                let signals = if let Some(db) = self.dbc_channels.get(&can_msg.channel) {
                    if let Some(message) = db.messages.get(&can_msg.id) {
                        message
                            .signals
                            .iter()
                            .map(|(name, signal)| {
                                let val = signal.decode(&can_msg.data);
                                format!("{}={:.2}", name, val)
                            })
                            .collect::<Vec<_>>()
                            .join(", ")
                    } else {
                        String::new()
                    }
                } else {
                    String::new()
                };

                (
                    time_str,
                    can_msg.channel,
                    "CAN".to_string(),
                    format!("0x{:03X}", can_msg.id),
                    actual_data_len.to_string(),
                    data_hex,
                    signals,
                )
            }
            LogObject::LinMessage(lin_msg) => {
                let timestamp = lin_msg.header.object_time_stamp;
                let time_str = self.get_timestamp_string(timestamp);
                let actual_data_len = lin_msg.data.len().min(lin_msg.dlc as usize);
                let data_hex = lin_msg
                    .data
                    .iter()
                    .take(actual_data_len)
                    .map(|b| format!("{:02X}", b))
                    .collect::<Vec<_>>()
                    .join(" ");

                let signals = if let Some(db) = self.ldf_channels.get(&lin_msg.channel) {
                    // Search for the frame with the matching ID
                    if let Some(frame) = db.frames.values().find(|f| f.id == lin_msg.id as u32) {
                        frame
                            .signals
                            .iter()
                            .filter_map(|mapping| {
                                db.signals
                                    .get(&mapping.signal_name)
                                    .map(|sig| (mapping, sig))
                            })
                            .map(|(mapping, signal)| {
                                let val = signal.decode(&lin_msg.data, mapping.offset);
                                format!("{}={}", signal.name, val)
                            })
                            .collect::<Vec<_>>()
                            .join(", ")
                    } else {
                        String::new()
                    }
                } else {
                    String::new()
                };

                (
                    time_str,
                    lin_msg.channel,
                    "LIN".to_string(),
                    format!("0x{:02X}", lin_msg.id),
                    actual_data_len.to_string(),
                    data_hex,
                    signals,
                )
            }
            _ => (
                "Unknown".to_string(),
                0,
                "Other".to_string(),
                "-".to_string(),
                "-".to_string(),
                "-".to_string(),
                String::new(),
            ),
        };

        let bg_color = if index.is_multiple_of(2) {
            rgb(0x09090b)  // Zed's dark background (zebra)
        } else {
            rgb(0x0c0c0e)  // Zed's dark background (base)
        };

        div()
            .flex()
            .w_full()
            .min_h(px(24.))  // Slightly taller for better readability
            .bg(bg_color)
            .border_b_1()
            .border_color(rgb(0x2a2a2a))  // Semi-transparent border like Zed
            .items_center()
            .text_sm()  // Slightly larger text like Zed
            .text_color(rgb(0xcdd6f4))  // Zed's default text color
            .hover(|style| style.bg(rgb(0x1f1f1f)))  // Subtle hover like Zed
            .cursor_pointer()
            .child(
                div()
                    .w(px(100.))
                    .px_3()
                    .py_1()
                    .text_color(rgb(0x646473))  // Zed's muted color
                    .child(time_str),
            )
            .child(
                div()
                    .w(px(40.))
                    .px_2()
                    .py_1()
                    .text_color(rgb(0x7dcfff))  // Zed's blue
                    .child(channel_id.to_string()),
            )
            .child(
                div()
                    .w(px(50.))
                    .px_2()
                    .py_1()
                    .text_color(rgb(0xa6e3a1))  // Zed's green
                    .child(msg_type),
            )
            .child(
                div()
                    .w(px(70.))
                    .px_2()
                    .py_1()
                    .text_color(rgb(0xf9e2af))  // Zed's yellow
                    .child(id_str),
            )
            .child(div().w(px(40.)).px_2().py_1().child(dlc_str))
            .child(
                div()
                    .w(px(150.))
                    .px_2()
                    .py_1()
                    .text_color(rgb(0xb4befe))  // Zed's purple
                    .child(data_str),
            )
            .child(
                div()
                    .flex_1()
                    .px_2()
                    .py_1()
                    .text_color(rgb(0x9399b2))  // Zed's comment color
                    .child(signals_str),
            )
    }

    /// Import a database file
    fn import_database_file(&mut self, cx: &mut Context<Self>) {
        if let Some(path) = rfd::FileDialog::new()
            .add_filter("Database Files", &["dbc", "ldf"])
            .pick_file()
        {
            let path_str = path.to_string_lossy().to_string();
            self.status_msg = format!("Loaded database: {}", path_str).into();
            cx.notify();
        }
    }

    /// Save the current configuration to file
    fn save_config(&self, cx: &mut Context<Self>) {
        let config_path = PathBuf::from("multi_channel_config.json");
        if let Ok(content) = serde_json::to_string_pretty(&self.app_config) {
            if std::fs::write(&config_path, content).is_ok() {
                cx.notify();
            }
        }
    }
}
